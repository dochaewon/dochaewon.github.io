---
title: "Laravel 11에서 예외 핸들링 커스터마이징하는 방법"
date: 2025-07-31
categories: \[Laravel, PHP]
tags: \[laravel11, exception handling, 예외처리, php, webdev]
---

## 🧩 들어가며

Laravel 11부터는 기존의 `Handler.php`가 사라지고, `bootstrap/app.php`에서의 직접적인 예외 핸들러 바인딩도 사용할 수 없습니다. 이로 인해 **기존 방식으로 커스텀 예외 핸들러를 등록하려던 많은 개발자들이 시행착오를 겪고 있습니다.**

이 글에서는 **Laravel 11의 구조적 변화**를 이해하고, 실제로 예외 핸들러를 커스터마이징하는 방법을 공유합니다.

---

## 📌 기존 Laravel 예외 핸들러 구조

Laravel 10까지는 다음 구조를 따랐습니다:

* `app/Exceptions/Handler.php`에서 `render()` 메서드를 오버라이딩
* 서비스 컨테이너에서 자동으로 Exception Handler가 등록됨

```php
public function render($request, Throwable $exception)
{
    if ($exception instanceof AuthorizationException) {
        return response()->json(['message' => '권한이 없습니다.'], 403);
    }

    return parent::render($request, $exception);
}
```

---

## ⚠️ Laravel 11의 변화

### ❌ `Handler.php` 없음

Laravel 11에서는 `app/Exceptions/Handler.php` 파일이 아예 생성되지 않으며, `Illuminate\Foundation\Exceptions\Handler`가 기본 핸들러로 작동합니다.

### ❌ `bind()` / `use()` 불가능

`bootstrap/app.php`에서 다음과 같은 코드도 더 이상 작동하지 않습니다:

```php
$app->bind(ExceptionHandler::class, CustomHandler::class); // 작동안함
```

이로 인해 커스텀 예외 핸들러를 등록하려면 **서비스 프로바이더를 통한 우회**가 필요합니다.

---

## ✅ 해결 방법: AppServiceProvider에서 등록하기

### 1. 커스텀 예외 핸들러 생성

```bash
php artisan make:exception CustomHandler
```

`app/Exceptions/CustomHandler.php` 생성 후, `Illuminate\Foundation\Exceptions\Handler`를 상속합니다.

```php
namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Throwable;

class CustomHandler extends ExceptionHandler
{
    public function render($request, Throwable $e)
    {
        if ($e instanceof AuthorizationException) {
            return response()->json([
                'message' => '이 작업은 권한이 없습니다.'
            ], 403);
        }

        return parent::render($request, $e);
    }
}
```

### 2. AppServiceProvider에서 수동 등록

`app/Providers/AppServiceProvider.php`의 `register()`에 다음 코드를 추가합니다:

```php
use Illuminate\Contracts\Debug\ExceptionHandler;
use App\Exceptions\CustomHandler;

public function register(): void
{
    $this->app->singleton(ExceptionHandler::class, CustomHandler::class);
}
```

이렇게 하면 Laravel 11에서도 커스텀 예외 핸들러가 정상 작동합니다.

---

## 🧪 테스트: authorize() 예외 처리

Policy에서 `authorize()` 호출 시 권한이 없으면 `AuthorizationException`이 발생합니다.

이때 위에서 등록한 커스텀 핸들러가 개입하여 다음과 같은 JSON을 응답으로 받을 수 있습니다:

```json
{
  "message": "이 작업은 권한이 없습니다."
}
```

---

## 🧵 마무리하며

Laravel 11의 구조 변경은 많은 자동화를 제거하고, 개발자에게 더 많은 제어권을 주지만, 동시에 **기존 습관과의 충돌**이 발생할 수 있습니다.

이번 경험을 통해 느낀 점:

* 문서가 아직 충분히 업데이트되지 않아 시행착오를 겪을 수 있음
* AppServiceProvider를 활용하면 대부분의 문제는 해결 가능

---

## 📚 관련 키워드

`#laravel11` `#exceptionhandler` `#laravel예외처리` `#laravelcustomhandler` `#phpwebdev`
